generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model comments {
  id       String   @id @default(auto()) @map("_id") @db.ObjectId
  date     DateTime @db.Date
  email    String
  movie_id String   @db.ObjectId
  name     String
  text     String
}

model User {
  id       String   @id @default(auto()) @map("_id") @db.ObjectId
  name     String
  email    String?  @unique
  password String
  role     UserRole @default(STUDENT)

  // öğrenciye özel alanlar
  tcNo    String? @unique
  groupId String? @db.ObjectId
  group   Group?  @relation(fields: [groupId], references: [id])

  // öğretmene özel alanlar
  branchId String? @db.ObjectId
  branch   Branch? @relation(fields: [branchId], references: [id])

  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  Feedback  Feedback[]
  Progress  Progress[]
}

enum UserRole {
  STUDENT
  TEACHER
  ADMIN
}

model Group {
  id                 String              @id @default(auto()) @map("_id") @db.ObjectId
  title              String
  description        String?
  students           User[]
  // contents           Content[]
  groupBranches      GroupBranch[]
  contentAccessRules ContentAccessRule[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Branch {
  id            String        @id @default(auto()) @map("_id") @db.ObjectId
  name          String
  teachers      User[]
  contents      Content[]
  groupBranches GroupBranch[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Group ve Branch arasında many-to-many ilişki kuruldu. Bu sayede dersler birden fazla gruba atanabilir.
model GroupBranch {
  id       String @id @default(auto()) @map("_id") @db.ObjectId
  group    Group  @relation(fields: [groupId], references: [id])
  groupId  String @db.ObjectId
  branch   Branch @relation(fields: [branchId], references: [id])
  branchId String @db.ObjectId
}

model Content {
  id          String        @id @default(auto()) @map("_id") @db.ObjectId
  title       String
  description String?
  type        ContentType
  url         String?
  status      ContentStatus @default(SCHEDULED)

   // tarihler öğretmen ve öğrenci için farklılık gösterecek.
   // publishAt_student DateTime?
   // publishAt_teacher DateTime?
   // endAt_student     DateTime?
   // endAt_teacher     DateTime?
   contentAccessRules ContentAccessRule[]

  // Arşivleme kontrolü
  isArchived Boolean   @default(false)
  archivedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  branchId String @db.ObjectId
  branch   Branch @relation(fields: [branchId], references: [id])
  
   // !! İçerik birden fazla gruba atanabileceği için bu kısım yorum satırına alındı. 
   // !! İçerik accessleri ContentAccessRule üzerinden kontrol edilir.
   // groupId  String @db.ObjectId
   // group    Group  @relation(fields: [groupId], references: [id])
}

model ContentAccessRule {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  contentId String  @db.ObjectId
  content   Content @relation(fields: [contentId], references: [id])

  role    UserRole // STUDENT, TEACHER
  groupId String?  @db.ObjectId
  group   Group?   @relation(fields: [groupId], references: [id])

  publishAt DateTime
  endAt     DateTime?
  isArchiveActive Boolean @default(false) // the archive is active or not for this content
}

model Feedback {
  id        String            @id @default(auto()) @map("_id") @db.ObjectId
  userId    String            @db.ObjectId
  user      User              @relation(fields: [userId], references: [id])
  title     String
  messages  FeedbackMessage[]
  status    FeedbackStatus    @default(PENDING)
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
}

model FeedbackMessage {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  feedbackId String   @db.ObjectId
  feedback   Feedback @relation(fields: [feedbackId], references: [id])
  message    String
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
}

enum FeedbackStatus {
  PENDING
  APPROVED
  CANCELED
  CLOSED
}

enum ContentStatus {
  DRAFT       // İçerik oluşturuldu ama daha bitmedi
  SCHEDULED   // Yayınlanma tarihi beklendiği için aktif değil
  ACTIVE      // Yayında
  ARCHIVED    // Yayından kaldırıldı
}

enum ContentType {
  VIDEO
  DOCUMENT
  INTERACTIVE
  GAME
}

// which student has completed what content
model Progress {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  studentId       String   @db.ObjectId
  student         User     @relation(fields: [studentId], references: [id])
  contentId       String   @db.ObjectId
  content         Content  @relation(fields: [contentId], references: [id])
  status          ProgressStatus @default(NOT_STARTED)
  completionDate  DateTime?
  interactionDetails Json?
}

enum ProgressStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
}

model ProgressBar {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  studentId   String   @db.ObjectId
  student     User     @relation(fields: [studentId], references: [id])
  date        DateTime // tracks progress for a specific day or period
  totalTasks  Int      // total number of tasks assigned to the student
  completedTasks Int   // number of tasks the student has completed
  progress    Float    // percentage of tasks completed (calculated as completedTasks / totalTasks * 100)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// it tracks system-wide statistics for admin
model Statistics {
  id                  String   @id @default(auto()) @map("_id") @db.ObjectId
  date                DateTime
  totalStudents       Int
  totalTasks          Int      // New field to track the total number of tasks assigned
  completedTasks      Int
  activeStudents      Int
  mostCompletedContentId String? @db.ObjectId
  leastCompletedContentId String? @db.ObjectId
  activeHours         Json
}
